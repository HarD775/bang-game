//
// $Id$

package com.threerings.bang.game.client;

import java.awt.event.ActionEvent;

import com.jme.input.KeyInput;
import com.jmex.bui.event.KeyEvent;
import com.jmex.bui.event.KeyListener;

import com.samskivert.util.HashIntMap;
import com.samskivert.util.Multex;

import com.threerings.crowd.client.PlaceView;
import com.threerings.crowd.data.BodyObject;
import com.threerings.crowd.data.PlaceConfig;
import com.threerings.crowd.data.PlaceObject;
import com.threerings.crowd.util.CrowdContext;
import com.threerings.util.MessageBundle;

import com.threerings.parlor.game.client.GameController;
import com.threerings.presents.dobj.AttributeChangedEvent;

import com.threerings.bang.game.data.BangConfig;
import com.threerings.bang.game.data.BangObject;
import com.threerings.bang.game.data.GameCodes;
import com.threerings.bang.game.data.card.Card;
import com.threerings.bang.game.data.piece.Piece;
import com.threerings.bang.game.data.piece.Unit;
import com.threerings.bang.game.util.PointSet;
import com.threerings.bang.util.BangContext;

import static com.threerings.bang.Log.log;

/**
 * Handles the logic and flow of the client side of a game.
 */
public class BangController extends GameController
{
    /** The name of the command posted by the "Back to lobby" button in
     * the side bar. */
    public static final String BACK_TO_LOBBY = "BackToLobby";

    /** A command that requests to place a card. */
    public static final String PLACE_CARD = "PlaceCard";

    /**
     * Configures a controller command that will be fired when the specified
     * key is pressed (assuming no key-listening component has focus like the
     * chat box).
     */
    public void mapCommand (int keyCode, String command)
    {
        _keycmds.put(keyCode, command);
    }

    @Override // documentation inherited
    public void init (CrowdContext ctx, PlaceConfig config)
    {
        super.init(ctx, config);
        _ctx = (BangContext)ctx;
        _config = (BangConfig)config;

        // we start the new round after the player has dismissed the
        // previous round's stats dialogue and the game is reported as
        // ready to go
        _selphaseMultex = new Multex(new Runnable() {
            public void run () {
                _view.selectionPhase(_bangobj, _config, _pidx);
            }
        }, 2);

        // there's no stats dialogue when we first enter, so start with
        // that condition already satisfied
        _selphaseMultex.satisfied(Multex.CONDITION_TWO);

        // wire up our command listener
        _view.addListener(new KeyListener() {
            public void keyPressed (KeyEvent event) {
                String cmd = (String)_keycmds.get(event.getKeyCode());
                if (cmd != null) {
                    handleAction(new ActionEvent(this, 0, cmd));
                }
            }
            public void keyReleased (KeyEvent event) {
            }
        });

        mapCommand(KeyInput.KEY_SPACE, "StartChat");
        mapCommand(KeyInput.KEY_ESCAPE, "ShowOptions");
        mapCommand(KeyInput.KEY_TAB, "SelectNextUnit");
    }

    @Override // documentation inherited
    public void willEnterPlace (PlaceObject plobj)
    {
        super.willEnterPlace(plobj);
        _bangobj = (BangObject)plobj;

        // determine our player index
        BodyObject me = (BodyObject)_ctx.getClient().getClientObject();
        _pidx = _bangobj.getPlayerIndex(me.getVisibleName());

        // we may be returning to an already started game
        if (_bangobj.state != BangObject.AWAITING_PLAYERS) {
            handleStateChange(_bangobj.state);
        }
    }

    /** Handles a request to leave the game. Generated by the {@link
     * #BACK_TO_LOBBY} command. */
    public void handleBackToLobby (Object source)
    {
        _ctx.getLocationDirector().moveBack();
    }

    /** Instructs the controller to activate the chat input. */
    public void handleStartChat (Object source)
    {
        _view.chat.requestFocus();
    }

    /** Instructs the controller to display the in-game options view. */
    public void handleShowOptions (Object source)
    {
        InGameOptionsView oview = new InGameOptionsView(_ctx);
        _ctx.getRootNode().addWindow(oview);
        oview.pack();
        oview.center();
    }

    /**
     * Instructs the controller to select the most sensible unit for this
     * player.
     */
    public void handleSelectNextUnit (Object source)
    {
        Piece[] pieces = _bangobj.getPieceArray();

        // start with the most recently selected unit
        int startidx = 0;
        for (int ii = 0; ii < pieces.length; ii++) {
            if (pieces[ii].pieceId == _lastSelection) {
                startidx = ii+1;
                break;
            }
        }

        // now find the next unit owned by this player
        Unit unit = null;
        for (int ii = 0; ii < pieces.length; ii++) {
            Piece piece = pieces[(ii+startidx)%pieces.length];
            if (piece instanceof Unit && piece.owner == _pidx) {
                unit = (Unit)piece;
                break;
            }
        }

        if (unit != null) {
            _lastSelection = unit.pieceId;
            _view.view.selectUnit(unit, true);
        }
    }

    /** Handles a request to move a piece. */
    public void moveAndFire (int pieceId, int tx, int ty, final int targetId)
    {
        final PointSet moves = new PointSet();
        moves.add(tx, ty);
        BangService.InvocationListener il =
            new BangService.InvocationListener() {
            public void requestFailed (String reason) {
                // TODO: play a sound or highlight the piece that failed
                // to move
                log.info("Thwarted! " + reason);
                _bangobj.board.dumpOccupiability(moves);

                // clear any pending shot indicator
                if (targetId != -1) {
                    _view.view.shotFailed(targetId);
                }
            }
        };
        log.info("Requesting move and fire [pid=" + pieceId +
                 ", to=+" + tx + "+" + ty + ", tid=" + targetId + "].");
        _bangobj.service.move(
            _ctx.getClient(), pieceId, (short)tx, (short)ty, targetId, il);
    }

    /** Handles a request to place a card. */
    public void placeCard (int cardId)
    {
        if (_bangobj == null || !_bangobj.isInPlay()) {
            return;
        }

        Card card = (Card)_bangobj.cards.get(cardId);
        if (card == null) {
            log.warning("Requested to place non-existent card '" +
                        cardId + "'.");
        } else {
            // instruct the board view to activate placement mode
            _view.view.placeCard(card);
        }
    }

    /** Handles a request to activate a card. */
    public void activateCard (int cardId, int tx, int ty)
    {
        if (_bangobj.cards.get(cardId) == null) {
            log.warning("Requested to activate expired card " +
                        "[id=" + cardId + "].");
        } else {
            _bangobj.service.playCard(
                _ctx.getClient(), cardId, (short)tx, (short)ty);
        }
    }

    @Override // documentation inherited
    public void attributeChanged (AttributeChangedEvent event)
    {
        super.attributeChanged(event);

        // once the awards are set, we can display the end of game stats
        if (event.getName().equals(BangObject.AWARDS)) {
            StringBuffer winners = new StringBuffer();
            for (int ii = 0; ii < _bangobj.winners.length; ii++) {
                if (_bangobj.winners[ii]) {
                    if (winners.length() > 0) {
                        winners.append(", ");
                    }
                    winners.append(_bangobj.players[ii]);
                }
            }
            String title = MessageBundle.tcompose("m.game_over_stats", winners);
            title = _ctx.xlate(GameCodes.GAME_MSGS, title);
            StatsDisplay stats =
                new StatsDisplay(_ctx, this, _bangobj, _pidx, title);
            _ctx.getRootNode().addWindow(stats);
            stats.pack();
            stats.center();
        }
    }

    @Override // documentation inherited
    protected PlaceView createPlaceView (CrowdContext ctx)
    {
        _view = new BangView((BangContext)ctx, this);
        return _view;
    }

    @Override // documentation inherited
    protected boolean handleStateChange (int state)
    {
        if (state == BangObject.SELECT_PHASE) {
            _selphaseMultex.satisfied(Multex.CONDITION_ONE);
            return true;

        } else if (state == BangObject.BUYING_PHASE) {
            _view.buyingPhase(_bangobj, _config, _pidx);
            return true;

        } else if (state == BangObject.POST_ROUND) {
            // let the view know that the round is over
            _view.view.endRound();

            // create the end of round stats display
            String title = _ctx.xlate(GameCodes.GAME_MSGS, "m.round_over_stats");
            StatsDisplay stats =
                new StatsDisplay(_ctx, this, _bangobj, _pidx, title);
            _ctx.getRootNode().addWindow(stats);
            stats.pack();
            stats.center();
            return true;

        } else {
            return super.handleStateChange(state);
        }
    }

    @Override // documentation inherited
    protected void gameDidStart ()
    {
        super.gameDidStart();

        _view.startGame(_bangobj, _config, _pidx);
    }

    @Override // documentation inherited
    protected void gameWillReset ()
    {
        super.gameWillReset();

        // let the view know that the game is over
        _view.endGame();
    }

    @Override // documentation inherited
    protected void gameDidEnd ()
    {
        super.gameDidEnd();

        // let the view know that the game is over
        _view.endGame();
    }

    /**
     * Called by the stats dialog when it has been dismissed.
     */
    protected void statsDismissed ()
    {
        log.info("Stats dismissed!");
        // if the game is over, head back to the lobby
        if (_bangobj.state == BangObject.GAME_OVER) {
            _ctx.getLocationDirector().leavePlace();

        } else {
            // otherwise potentially display the selection phase dialog
            // for the next round
            _selphaseMultex.satisfied(Multex.CONDITION_TWO);
        }
    }

    /** A casted reference to our context. */
    protected BangContext _ctx;

    /** The configuration of this game. */
    protected BangConfig _config;

    /** Contains our main user interface. */
    protected BangView _view;

    /** A casted reference to our game object. */
    protected BangObject _bangobj;

    /** Our player index or -1 if we're not a player. */
    protected int _pidx;

    /** The unit id of the unit most recently selected via {@link
     * #handleSelectNextUnit}. */
    protected int _lastSelection = -1;

    /** Used to start the new round after two conditions have been met. */
    protected Multex _selphaseMultex;

    /** Maps keys to controller commands. */
    protected HashIntMap _keycmds = new HashIntMap();
}
