//
// $Id$

package com.threerings.bang.editor;

import javax.swing.JFileChooser;

import java.io.File;
import java.io.IOException;
import java.util.Iterator;

import com.samskivert.util.StringUtil;

import com.threerings.util.MessageBundle;

import com.threerings.presents.dobj.EntryAddedEvent;
import com.threerings.presents.dobj.EntryRemovedEvent;
import com.threerings.presents.dobj.EntryUpdatedEvent;
import com.threerings.presents.dobj.SetListener;

import com.threerings.crowd.client.PlaceView;
import com.threerings.crowd.data.PlaceConfig;
import com.threerings.crowd.data.PlaceObject;
import com.threerings.crowd.util.CrowdContext;

import com.threerings.parlor.game.client.GameController;

import com.threerings.bang.game.data.BangObject;
import com.threerings.bang.game.data.PieceDSet;
import com.threerings.bang.game.data.piece.Marker;
import com.threerings.bang.game.data.piece.Piece;
import com.threerings.bang.server.persist.BoardRecord;

import static com.threerings.bang.Log.log;

/**
 * Handles the logic and flow for the Bang! board editor.
 */
public class EditorController extends GameController
{
    /** Requests that we terminate the editor. */
    public static final String EXIT = "Exit";

    /** Instructs us to create a piece of the supplied type. */
    public static final String CREATE_PIECE = "CreatePiece";

    /** Instructs us to remove the specified piece. */
    public static final String REMOVE_PIECE = "RemovePiece";

    /** Instructs us to load a new board. */
    public static final String LOAD_BOARD = "LoadBoard";

    /** Instructs us to save the current board. */
    public static final String SAVE_BOARD = "SaveBoard";

    /** Handles a request to exit the editor. Generated by the {@link
     * #EXIT} command. */
    public void handleExit (Object source)
    {
        // TODO: warn about an unsaved board
        System.exit(0);
    }

    /** Handles a request to create a new piece and add it to the board.
     * Generated by the {@link #CREATE_PIECE} command. */
    public void handleCreatePiece (Object source, Piece piece)
    {
        piece = (Piece)piece.clone();
        piece.assignPieceId();
        piece.position(0, 0);
        _bangobj.addToPieces(piece);
    }

    /** Handles a request to create a new piece and add it to the board.
     * Generated by the {@link #REMOVE_PIECE} command. */
    public void handleRemovePiece (Object source, Integer key)
    {
        _bangobj.removeFromPieces(key);
    }

    /** Handles a request to load the current board.  Generated by the
     * {@link #LOAD_BOARD} command. */
    public void handleLoadBoard (Object source)
    {
        if (_chooser == null) {
            _chooser = new JFileChooser(_board.getParent());
        }
        int rv = _chooser.showOpenDialog(_ctx.getFrame());
        if (rv != JFileChooser.APPROVE_OPTION) {
            return;
        }

        loadBoard(_chooser.getSelectedFile());
    }

    /** Handles a request to save the current board.  Generated by the
     * {@link #SAVE_BOARD} command. */
    public void handleSaveBoard (Object source)
    {
        if (_chooser == null) {
            _chooser = new JFileChooser(_board.getParent());
        }
        int rv = _chooser.showSaveDialog(_ctx.getFrame());
        if (rv != JFileChooser.APPROVE_OPTION) {
            return;
        }

        try {
            File board = _chooser.getSelectedFile();
            BoardRecord brec = new BoardRecord();
            _panel.info.toBoard(brec);
            brec.setData(_bangobj.board, _bangobj.getPieceArray());
            brec.save(board);
            _board = board;
            _ctx.setWindowTitle(_board.toString());
            _ctx.displayStatus(_msgs.get("m.saved", _board));

        } catch (IOException ioe) {
            _ctx.displayStatus(_msgs.get("m.save_error", ioe.getMessage()));
        }
    }

    // documentation inherited
    public void init (CrowdContext ctx, PlaceConfig config)
    {
        super.init(ctx, config);
        _ctx = (EditorContext)ctx;
        _config = (EditorConfig)config;
        _msgs = _ctx.getMessageManager().getBundle("editor");
    }

    // documentation inherited
    public void willEnterPlace (PlaceObject plobj)
    {
        super.willEnterPlace(plobj);
        _bangobj = (BangObject)plobj;
        _bangobj.addListener(_pclistener);
    }

    protected void loadBoard (File board)
    {
        try {
            BoardRecord brec = new BoardRecord();
            brec.load(board);
            _bangobj.setBoard(brec.getBoard());
            Piece[] pieces = brec.getPieces();
            // reassign piece ids
            for (int ii = 0; ii < pieces.length; ii++) {
                pieces[ii].pieceId = (ii+1);
            }
            Piece.setNextPieceId(pieces.length);
            _bangobj.setPieces(new PieceDSet(pieces));
            _panel.view.refreshBoard();
            _panel.info.fromBoard(brec);
            updatePlayerCount();
            _board = board;
            _ctx.setWindowTitle(_board.toString());
            _ctx.displayStatus(_msgs.get("m.loaded", _board));

        } catch (IOException ioe) {
            _ctx.displayStatus(_msgs.get("m.load_error", ioe.getMessage()));
        }
    }

    @Override // documentation inherited
    protected PlaceView createPlaceView (CrowdContext ctx)
    {
        _panel = new EditorPanel((EditorContext)ctx, this);
        return _panel;
    }

    @Override // documentation inherited
    protected void gameDidStart ()
    {
        super.gameDidStart();

        // our panel needs to do some game starting business
        _panel.startGame(_bangobj, _config);

        // load up any board specified on the command line
        if (EditorApp.appArgs.length > 0 &&
            !StringUtil.blank(EditorApp.appArgs[0])) {
            loadBoard(new File(EditorApp.appArgs[0]));
        }
    }

    @Override // documentation inherited
    protected void gameWillReset ()
    {
        super.gameWillReset();
        _panel.endGame();
    }

    @Override // documentation inherited
    protected void gameDidEnd ()
    {
        super.gameDidEnd();
        _panel.endGame();
    }

    protected void updatePlayerCount ()
    {
        int pcount = 0;
        for (Iterator iter = _bangobj.pieces.iterator(); iter.hasNext(); ) {
            if (Marker.isMarker((Piece)iter.next(), Marker.START)) {
                pcount++;
            }
        }
        _panel.info.updatePlayers(pcount);
    }

    /** Listens for piece additions and removals. */
    protected SetListener _pclistener = new SetListener() {
        public void entryAdded (EntryAddedEvent event) {
            updatePlayerCount();
        }
        public void entryUpdated (EntryUpdatedEvent event) {
        }
        public void entryRemoved (EntryRemovedEvent event) {
            updatePlayerCount();
        }
    };

    /** A casted reference to our context. */
    protected EditorContext _ctx;

    /** The configuration of this game. */
    protected EditorConfig _config;

    /** Used to translate messages. */
    protected MessageBundle _msgs;

    /** Contains our main user interface. */
    protected EditorPanel _panel;

    /** A casted reference to our game object. */
    protected BangObject _bangobj;

    /** The file chooser we use for loading and saving. */
    protected JFileChooser _chooser;

    /** A reference to the file associated with the board we're editing. */
    protected File _board = new File("");
}
